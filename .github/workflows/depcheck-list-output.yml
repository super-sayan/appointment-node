name: Check Unused Dependencies (List)
on:
  workflow_dispatch:

env:
  NODE_VERSION: 16.x # Node.js version
  PACKAGE_DIRS: ". ./client ./server" # Directories where package.json files are located on my local repo, don't need it in future versions
  DEPENDENCY_TRACK_API_KEY: ${{ secrets.DEPENDENCYTRACK_APIKEY }} # API Key for using Dependecy Track API
  DEPENDENCY_TRACK_BASE_URL: ${{ secrets.API_URL }} # URL of Dependency Track API server
  PROJECT_NAME: ${{ github.repository }}  # Replace with repo name later

jobs:
  code_analysis:
    runs-on: ubuntu-latest

    steps:
      # Define repo for output of results.
      - name: Checkout Code
        uses: actions/checkout@v4
      # Define Programming Language.
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
      
      # Installing dependencies from package.json files of repo.
      - name: Install Dependencies
        run: |
          for dir in ${{ env.PACKAGE_DIRS }}; do
            echo "Installing dependencies in $dir"
            cd "$dir" || exit
            npm install
            cd - || exit
          done
        shell: bash
      
      # Running Dependecy Check to define unused dependencies and create txt of unused deps.
      - name: Run Depcheck and Write to List
        run: |
          echo "Unused Dependencies:" > unused_dependencies.txt
          for dir in ${{ env.PACKAGE_DIRS }}; do
            echo "Running depcheck in $dir..."
            cd "$dir" || exit
            output=$(npx depcheck || true)
      
            # Parse and annotate unused dependencies.
            if echo "$output" | grep -q "Unused dependencies"; then
              echo "$output" | sed -n '/Unused dependencies/,$p' | while IFS= read -r line; do
                if [[ $line == "*"* ]]; then
                  dep=$(echo "$line" | sed -E 's/\* //; s/:.*$//')
                  echo "$dep" >> ../unused_dependencies.txt
                fi
              done
            fi

            # Parse and annotate unused devDependencies.
            if echo "$output" | grep -q "Unused devDependencies"; then
              echo "$output" | sed -n '/Unused devDependencies/,$p' | while IFS= read -r line; do
                if [[ $line == "*"* ]]; then
                  dep=$(echo "$line" | sed -E 's/\* //; s/:.*$//')
                  echo "$dep" >> ../unused_dependencies.txt
                fi
              done
            fi
            cd - || exit
          done
          cat unused_dependencies.txt
      
      # Installing Trivy for SBOM generation.
      - name: Install Trivy for SBOM Generation
        run: |
          curl -sSL https://github.com/aquasecurity/trivy/releases/download/v0.58.0/trivy_0.58.0_Linux-64bit.tar.gz | sudo tar xz -C /usr/local/bin
      
      # Generating SBOM using Trivy.
      - name: Generate SBOM using Trivy
        run: |
          trivy fs --format cyclonedx --output sbom.json .

      # Remove unused dependecies from generated SBOM.
      - name: Remove Unused Dependencies from SBOM
        run: |
          echo "Removing unused dependencies from SBOM"
    
          # Read unused dependencies into a list.
          unused_deps=$(cat unused_dependencies.txt)
    
          # Convert the list into a JSON array of objects with `group` and `name`.
          unused_json=$(echo "$unused_deps" | jq -R -s '
            split("\n") | 
            map(select(length > 0)) |
            map(if test("^@") then 
                  {group: (split("/")[0]), name: (split("/")[1])} 
                else 
                  {group: null, name: .} 
                end)
          ')

          # Filter components, matching against both `group` and `name`.
          jq --argjson unused "$unused_json" '
            .components |= map(select(
              .name as $name | 
              .group as $group |
              ($unused | map(.name == $name and .group == $group) | any) | not
            ))
          ' sbom.json > filtered_sbom.json
   
   # An official Dependecy Track action for SBOM upload, doesn't work good with full URL of Dep Track Server.
   #   - name: Upload SBOM to Dependency Track
   #     uses: DependencyTrack/gh-upload-sbom@v3
   #     with:
   #       serverHostname: ${{ env.DEPENDENCY_TRACK_BASE_URL }}
   #       apiKey: ${{ env.DEPENDENCY_TRACK_API_KEY }}
   #       projectName: ${{ env.PROJECT_NAME }} # change projectName -> to repo_name
   #       projectVersion: '1.0.0'
   #       bomFilename: "./filtered_sbom.json" # Adjust path if needed
   #       autoCreate: true

      # Uploading SBOM to Dependency Track for analysis.   
      - name: Upload SBOM to Dependency Track
        id: SBOM-upload
        run: |
          curl -X "POST" "${{ env.DEPENDENCY_TRACK_BASE_URL }}/api/v1/bom" \
               -H 'Content-Type: multipart/form-data' \
               -H "X-Api-Key: ${{ env.DEPENDENCY_TRACK_API_KEY }}" \
               -F "autoCreate=true" \
               -F "projectName=${{ env.PROJECT_NAME }}" \
               -F "projectVersion=1.0.0" \
               -F "bom=@./filtered_sbom.json"

      # Getting uuid of Project, that we have created on the previous step.
      - name: Fetch Project ID
        id: fetch-project
        run: |
          project_id=$(curl -s -H "X-Api-Key: ${{ env.DEPENDENCY_TRACK_API_KEY }}" \
          "${{ env.DEPENDENCY_TRACK_BASE_URL }}/api/v1/project" | jq -r '.[] | select(.name == "${{ env.PROJECT_NAME }}") | .uuid')
          echo "Project ID: $project_id"
          echo "project_id=$project_id" >> $GITHUB_ENV

      # Getting analysis results from project using it's uuid in sarif/json format.
      - name: Fetch EPSS Data
        id: fetch-epss
        run: |
          curl -s -H "X-Api-Key: ${{ env.DEPENDENCY_TRACK_API_KEY }}" \
          "${{ env.DEPENDENCY_TRACK_BASE_URL }}/api/v1/finding/project/$project_id" \
          -o epss.json  
          echo "EPSS data fetched successfully." 
      # -H "Accept: application/sarif+json" \
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Convert JSON to SARIF
        run: |
          python - <<EOF
          import json
          import hashlib
          
          
          def generate_fingerprint(purl, vuln_id):
              """
              Generate a unique fingerprint based on the package URL (purl) and vulnerability ID.
              
              Args:
                  purl (str): Package URL.
                  vuln_id (str): Vulnerability ID.
                  
              Returns:
                  str: Truncated SHA256 hash.
              """
              data = f"{purl}:{vuln_id}"
              hash_object = hashlib.sha256(data.encode())
              return hash_object.hexdigest()[:16]
          
          
          def transform_to_sarif(dependency_track_json, output_file_path):
              """
              Transforms Dependency Track JSON output to SARIF format.
              
              Args:
                  dependency_track_json (str): Path to Dependency Track JSON file.
                  output_file_path (str): Path to save the SARIF file.
              """
              with open("epss.json", 'r') as file:
                  vulnerabilities = json.load(file)
              
              sarif = {
                  "$schema": "https://json.schemastore.org/sarif-2.1.0.json",
                  "version": "2.1.0",
                  "runs": [
                      {
                          "tool": {
                              "driver": {
                                  "name": "Dependency Track",
                                  "rules": []
                              }
                          },
                          "results": []
                      }
                  ]
              }
              
              # Mapping vulnerabilities to SARIF rules and results
              for entry in vulnerabilities:
                  component = entry["component"]
                  vulnerability = entry["vulnerability"]
                  
                  # Add a rule for each unique vulnerability
                  rule = {
                      "id": vulnerability["vulnId"],
                      "properties": {
                          "id": vulnerability["vulnId"],
                          "kind": "path-problem",
                          "name": vulnerability.get("cweName", "Unknown CWE"),
                          "problem.severity": vulnerability["severity"].lower(),
                          "security-severity": vulnerability.get("cvssV3BaseScore", 0),
                      }
                  }
                  sarif["runs"][0]["tool"]["driver"]["rules"].append(rule)
                  
                  # Add a result for each vulnerability instance
                  result = {
                      "ruleId": vulnerability["vulnId"],
                      "message": {
                          "text": vulnerability["description"]
                      },
                      "locations": [
                          {
                              "physicalLocation": {
                                  "artifactLocation": {
                                      "uri": "package.json"
                                  },
                                  "region": {
                                      "startLine": 1,
                                      "startColumn": 1,
                                      "endColumn": 1
                                  }
                              }
                          }
                      ],
                      "partialFingerprints": {
                          "primaryLocationLineHash": generate_fingerprint(
                              component["purl"], vulnerability["vulnId"]
                          )
                      }
                  }
                  sarif["runs"][0]["results"].append(result)
              
              # Save SARIF file
              with open(output_file_path, 'w') as file:
                  json.dump(sarif, file, indent=2)
              
              print(f"SARIF file saved to {output_file_path}")
          
          
          # Example Usage
          transform_to_sarif("dependency_track_output.json", "epss.sarif")

          EOF


# Action for downloading json/sarif result files for errors handling.      
#      - name: Download Results Dependencies
#        uses: actions/upload-artifact@v3
#        with:
#          name: epss-json
#          path: epss.json     
          
      # Official Github Action for uploading results in sarif format to Github Security tab.
      - name: Upload EPSS Data as SARIF
        uses: github/codeql-action/upload-sarif@v3
        with:
          token: ${{ secrets.PAT }}
          sarif_file: epss.sarif # sarif_file: ${{ steps.fetch-project.outputs.epss }}
          category: dependency-track
      
      # This code is used to create issues from epps.json results file if we won't succeed in  finding solution for uploading results to security tab.
      # - name: Parse JSON and create issues
      #   run: |
      #     # Install jq for JSON parsing
      #     sudo apt-get install jq

      #     # Parse JSON file and create issues via GitHub API
      #     cat epss.json | jq -c '.[]' | while read -r item; do
      #       vuln_id=$(echo $item | jq -r '.vulnerability.vulnId')
      #       description=$(echo $item | jq -r '.vulnerability.description')
      #       severity=$(echo $item | jq -r '.vulnerability.severity')
      #       epss_score=$(echo $item | jq -r '.vulnerability.epssScore')
      #       component_name=$(echo $item | jq -r '.component.name')
      #       component_version=$(echo $item | jq -r '.component.version')

      #       # Determine EPSS Level
      #       if (( $(echo "$epss_score > 0.5" | bc -l) )); then
      #         epss_level="High EPSS"
      #       elif (( $(echo "$epss_score > 0.2" | bc -l) )); then
      #         epss_level="Medium EPSS"
      #       else
      #         epss_level="Low EPSS"
      #       fi

      #       # Ensure unique issue title by appending the vulnerability ID
      #       title="Vulnerability - $vuln_id ($component_name $component_version)"

      #       # Issue Body: Includes description, severity, and EPSS information
      #       body="**Vulnerability ID**: $vuln_id\n\n**Description**: $description\n\n**Severity**: $severity\n\n**EPSS Score**: $epss_score ($epss_level)"

      #       # Create issue using GitHub API
      #       curl -X POST \
      #         -H "Authorization: token ${{ secrets.PAT }}" \
      #         -d '{"title": "'"$title"'", "body": "'"$body"'", "labels": ["security", "'"$severity"'", "'"$epss_level"'"]}' \
      #         https://api.github.com/repos/${{ github.repository }}/issues
      #     done
